package org.opengeoportal.messaging;

/**
 * Created by cbarne02 on 3/2/16.
 */
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;

import org.springframework.stereotype.Service;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import java.util.UUID;

/**
 * Service that sends a JMS message with a download request.
 */
@Service
public class DownloadRequestSender {
    private final String DOWNLOAD_REQUEST_QUEUE = "download.request";
    private final JmsTemplate jmsTemplate;

    private ObjectMapper mapper = new ObjectMapper();

    private Logger logger = LoggerFactory.getLogger(DownloadRequestSender.class);

    //TODO: set a flag for whether or not a response has been sent. could be multiple sets of
    //id/requests, so we need something like a map. methods here should be thread safe or
    //a new instance should be spawned with shared id/request map.
    //when a reply is received, check the id/request map and retrieve the deferredresult
    //generated by the controller.
    //
    //when the user/client checks status, first check the reply status flag. otherwise we have
    //to keep a thread around waiting. if no, send back a processing status. if yes, either send a
    // "fail" status with message or a "success" status with a link.
    @Autowired
    public DownloadRequestSender(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    /**
     * Send a download request to a JMS queue.
     *
     * Generates a UUID to send as the JMS Correlation Id, so that we can correctly match up a response. The message
     * payload is sent as JSON string to avoid safety issues with Object payloads and to potentially allow non-JAVA
     * clients.
     *
     * @param downloadRequest
     * @return
     */
    public String send(DownloadRequest downloadRequest){
        String id = UUID.randomUUID().toString();
        try {
            String message = mapper.writeValueAsString(downloadRequest);
            MessageCreator messageCreator = getMessageCreator(message, id);
            jmsTemplate.send(DOWNLOAD_REQUEST_QUEUE, messageCreator);

        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }

        return id;
    }

    private MessageCreator getMessageCreator(String message, String messageId){
        return new MessageCreator() {
            @Override
            public Message createMessage(Session session) throws JMSException {

                Message dlmessage =  session.createTextMessage(message);
                logger.debug("MessageId sent: " + messageId);
                dlmessage.setJMSCorrelationID(messageId);
                // set a replyTo to a temporary queue? Or is the system smart enough to know
                // which sender to reply to (specific queue, not just THE queue)
                //dlmessage.setJMSReplyTo();
                return dlmessage;
            }
        };
    };



}
